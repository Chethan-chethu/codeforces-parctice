//	D. Subtract Min Sort
//	time limit per test2 seconds
//	memory limit per test256 megabytes
//	You are given a sequence a
//	 consisting of n
//	 positive integers.
//	
//	You can perform the following operation any number of times.
//	
//	Select an index i
//	 (1≤i<n
//	), and subtract min(ai,ai+1)
//	 from both ai
//	 and ai+1
//	.
//	Determine if it is possible to make the sequence non-decreasing by using the operation any number of times.
//	
//	Input
//	Each test contains multiple test cases. The first line contains the number of test cases t
//	 (1≤t≤104
//	). The description of the test cases follows.
//	
//	The first line of each test case contains a single integer n
//	 (2≤n≤2⋅105
//	).
//	
//	The second line of each test case contains a1,a2,…,an
//	 (1≤ai≤109
//	).
//	
//	It is guaranteed that the sum of n
//	 over all test cases does not exceed 2⋅105
//	.
//	
//	Output
//	If it is possible to make the sequence non-decreasing, print "YES" on a new line. Otherwise, print "NO" on a new line.
//	
//	You can output the answer in any case. For example, the strings "yEs", "yes", and "Yes" will also be recognized as positive responses.
//	
//	Example
//	InputCopy
//	5
//	5
//	1 2 3 4 5
//	4
//	4 3 2 1
//	4
//	4 5 2 3
//	8
//	4 5 4 5 4 5 4 5
//	9
//	9 9 8 2 4 4 3 5 3
//	OutputCopy
//	YES
//	NO
//	YES
//	YES
//	NO
//	Note
//	In the first test case, the array is already sorted.
//	
//	In the second test case, we can show that it is impossible.
//	
//	In the third test case, after performing an operation on i=1
//	, the array becomes [0,1,2,3]
//	, which is now in nondecreasing order.

package february;

import java.util.Scanner;

public class SubtractMinSort2060D {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int tests=sc.nextInt();
		while(tests-->0) {
			int n=sc.nextInt();
			int[] a=new int[n];
			for(int i=0;i<n;i++)a[i]=sc.nextInt();
			int i=0;
			for(i=0;i<n-1;i++) {
				// The only way to manipulate the value of index 0 is through next
				// adjacent index ie 1 in this case , if a[0]>a[1]
				// then there is no way to make a[0]<=a[1]
				// which means the sequence will never be sorted in non decreasing				
				if(a[i]>a[i+1]) {
					System.out.println("NO");
					break;
				}
				// if a[1]>=a[0] , then perform operation to greedily reduce the value
				// of a[1] for upcoming a[2] , for our algo to procced further				
				a[i+1]=a[i+1]-a[i];
			}
			if(i==n-1)System.out.println("YES");
		}
	}
}
