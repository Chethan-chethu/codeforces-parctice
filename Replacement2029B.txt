//	B. Replacement
//	time limit per test1 second
//	memory limit per test256 megabytes
//	You have a binary string∗
//	 s
//	 of length n
//	, and Iris gives you another binary string r
//	 of length n−1
//	.
//	
//	Iris is going to play a game with you. During the game, you will perform n−1
//	 operations on s
//	. In the i
//	-th operation (1≤i≤n−1
//	):
//	
//	First, you choose an index k
//	 such that 1≤k≤|s|−1
//	 and sk≠sk+1
//	. If it is impossible to choose such an index, you lose;
//	Then, you replace sksk+1
//	 with ri
//	. Note that this decreases the length of s
//	 by 1
//	.
//	If all the n−1
//	 operations are performed successfully, you win.
//	
//	Determine whether it is possible for you to win this game.
//	
//	∗
//	A binary string is a string where each character is either 0
//	 or 1
//	.
//	
//	Input
//	Each test contains multiple test cases. The first line of the input contains a single integer t
//	 (1≤t≤104
//	) — the number of test cases. The description of test cases follows.
//	
//	The first line of each test case contains a single integer n
//	 (2≤n≤105
//	) — the length of s
//	.
//	
//	The second line contains the binary string s
//	 of length n
//	 (si=0
//	 or 1
//	).
//	
//	The third line contains the binary string r
//	 of length n−1
//	 (ri=0
//	 or 1
//	).
//	
//	It is guaranteed that the sum of n
//	 over all test cases does not exceed 105
//	.
//	
//	Output
//	For each test case, print "YES" (without quotes) if you can win the game, and "NO" (without quotes) otherwise.
//	
//	You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and "YES" will be recognized as positive responses.
//	
//	Example
//	InputCopy
//	6
//	2
//	11
//	0
//	2
//	01
//	1
//	4
//	1101
//	001
//	6
//	111110
//	10000
//	6
//	010010
//	11010
//	8
//	10010010
//	0010010
//	OutputCopy
//	NO
//	YES
//	YES
//	NO
//	YES
//	NO
//	Note
//	In the first test case, you cannot perform the first operation. Thus, you lose the game.
//	
//	In the second test case, you can choose k=1
//	 in the only operation, and after that, s
//	 becomes equal to 1
//	. Thus, you win the game.
//	
//	In the third test case, you can perform the following operations: 110–––1−→−−r1=0101–––−→−−r2=010–––−→−−r3=11
//	.

package february;

import java.util.Scanner;

public class Replacement2029B {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int tests=sc.nextInt();
		while(tests-->0) {
			int n=sc.nextInt();
			String str1=sc.next();
			String str2=sc.next();
			int cntZ=0,cntO=0;
			for(int i=0;i<n;i++) {
				if(str1.charAt(i)=='1')cntO++;
				else cntZ++;
			}
			boolean can=true;
			// the operations (n-1) from str2 can only be performed if
			// there is non pairity present in str1 , if only 1's/only 0's
			// then it cannot be performed , notice that after each operation 
			// if the current index str2[i]==0 then the 10/01 in str1
			// gets replaced by 0 and reduces the count of one and vice versa
			for(int i=0;i<n-1;i++) {
				if(cntO==0 || cntZ==0) {					
					can=false;
					break;
				}
				if(str2.charAt(i)=='1')cntZ--;
				else cntO--;
			}
			System.out.println(can? "YES": "NO");
			}
		sc.close();
	}
}
