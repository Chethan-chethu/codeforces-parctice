//	D. Place of the Olympiad
//	time limit per test1 second
//	memory limit per test256 megabytes
//	For the final of the first Olympiad by IT Campus "NEIMARK", a rectangular venue was prepared. You may assume that the venue is divided into n
//	 rows, each containing m
//	 spots for participants' desks. A total of k
//	 participants have registered for the final, and each participant will sit at an individual desk. Now, the organizing committee must choose the locations for the desks in the venue.
//	
//	Each desk occupies one of the m
//	 spots in a row. Moreover, if several desks occupy consecutive spots in the same row, we call such a group of desks a bench, and the number of desks in the group is the bench's length. For example, seating 7
//	 participants on a 3×4
//	 venue (with n=3,m=4
//	) can be arranged as follows:
//	
//	
//	In the figure above, the first row has one bench of length 3
//	, the second row has one bench of length 2
//	, and the third row has two benches of length 1
//	.
//	
//	The organizing committee wants to choose the locations so that the length of the longest bench is as small as possible. In particular, the same 7
//	 desks can be arranged in a more optimal way, so that the lengths of all benches do not exceed 2
//	:
//	
//	
//	Given the integers n
//	, m
//	, and k
//	, determine the minimum possible length of the longest bench.
//	
//	Input
//	Each test contains multiple test cases. The first line contains the number of test cases t
//	 (1≤t≤104
//	). The description of the test cases follows.
//	
//	A single line of each test case contains three positive integers — n
//	, m
//	, k
//	 (1≤n,m,k≤109
//	, k≤n⋅m
//	).
//	
//	Output
//	For each test case, output a single number — the minimum possible length of the longest bench.
//	
//	Example
//	InputCopy
//	5
//	3 4 7
//	5 5 5
//	1 13 2
//	2 4 7
//	1 5 4
//	OutputCopy
//	2
//	1
//	1
//	4
//	2

package february;

import java.util.Scanner;

public class PlaceOfTheOlympiad2091D {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int tests=sc.nextInt();
		// tried binary search , but couldn't implement it		
		while(tests-->0) {
			 long n= sc.nextLong();
	            long m= sc.nextLong();
	            long k= sc.nextLong();
	            // get all the remaining no of spaces in the grid	            
	            long spaces= (n*m)-k;
	            // tnotice we are taking the floor , because 
	            // we should take the smallest space available for any
	            // row , when all the spaces are distributed equally
	            long spaceseachrow= spaces/n;
	            
	            // now we can divide the configuration into
	            // benches with space+1 total spaces 
	            // because the last bench wouldn't need space between the
	            // next bench as it is the last one
	            long longestbench= m/(spaceseachrow+1);
	           System.out.println(longestbench);
		}
		sc.close();
	}
}
