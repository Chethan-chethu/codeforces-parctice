//	C. XOR and Triangle
//	time limit per test2 seconds
//	memory limit per test256 megabytes
//	This time, the pink soldiers have given you an integer x
//	 (x≥2
//	).
//	
//	Please determine if there exists a positive integer y
//	 that satisfies the following conditions.
//	
//	y
//	 is strictly less than x
//	.
//	There exists a non-degenerate triangle∗
//	 with side lengths x
//	, y
//	, x⊕y
//	. Here, ⊕
//	 denotes the bitwise XOR operation.
//	Additionally, if there exists such an integer y
//	, output any.
//	
//	∗
//	A triangle with side lengths a
//	, b
//	, c
//	 is non-degenerate when a+b>c
//	, a+c>b
//	, b+c>a
//	.
//	
//	Input
//	Each test contains multiple test cases. The first line contains the number of test cases t
//	 (1≤t≤2000
//	). The description of the test cases follows.
//	
//	The only line of each test case contains a single integer x
//	 (2≤x≤109
//	).
//	
//	Output
//	For each test case, print one integer on a separate line. The integer you must output is as follows:
//	
//	If there exists an integer y
//	 satisfying the conditions, output the value of y
//	 (1≤y<x
//	);
//	Otherwise, output −1
//	.
//	If there exist multiple integers that satisfy the conditions, you may output any.
//	
//	Example
//	InputCopy
//	7
//	5
//	2
//	6
//	3
//	69
//	4
//	420
//	OutputCopy
//	3
//	-1
//	5
//	-1
//	66
//	-1
//	320
//	Note
//	In the first test case, there exists a non-degenerate triangle with side lengths 3
//	, 5
//	, and 3⊕5=6
//	. Therefore, y=3
//	 is a valid answer.
//	
//	In the second test case, 1
//	 is the only possible candidate for y
//	, but it cannot make a non-degenerate triangle. Therefore, the answer is −1
//	.

package february;

import java.util.Scanner;

public class XorAndTraingle2074C {
	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int tests=sc.nextInt();
		while(tests-->0) {
		int x=sc.nextInt();
		int ans=-1;
		// it has been explained in the solution that , y
		// contains one bit not set in x , and one bit set
		// in x , so brute force through all the probabilities
		for(int i=0;i<=30;i++) {
			for(int j=0;j<=30;j++) {
				int y=(1<<i)|(1<<j);
				int z=x^y;
				if(x>y && y+z>x && x+y>z) {
					ans=y;
					break;
				}
			}
			 if(ans!=-1)break;
		}
		System.out.println(ans);
		}
		sc.close();
	}
}

//	Let us interpret the triangle inequality in terms of bitmasking. Then, we get the following. (One is omitted as it is implied in the constraints.)
//	
//	x+y>x⊕y
//	, (x⊕y)+2(x&y)>x⊕y
//	, x&y>0
//	;
//	y+(x⊕y)>x
//	, y+(x+y)−2(x&y)>x
//	, y>x&y
//	.
//	In other words, y
//	 satisfies the following conditions.
//	
//	y
//	 contains at least one bit turned on in x
//	;
//	y
//	 contains at least one bit not turned on in x
//	.
//	The smallest values of y
//	 that satisfy this have exactly two bits turned on; one in x
//	 and one not in it. Therefore, if one such value exists, then a smallest one can be found in O(log2x)
//	 time by simply bruteforcing all integers with two bits turned on. If any one of them is less than x
//	, then it satisfies all conditions.
//	
//	The problem has been solved in O(log2x)
//	 per test case. While there exist ways to solve it in O(logx)
//	 per test case, they were not required.
